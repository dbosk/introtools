\tableofcontents

\section{Overview}

We create an include file, [[common.sh]], to be included in other grading 
scripts.
<<common.sh>>=
<<variables>>
<<function returning students to grade>>
<<function returning students to grade with last grading time>>
<<clone repos>>
<<check dates on repos>>
<<handle ssh logins>>
@


\section{Students to grade}

We will construct a function that returns a list of students who need grading 
for a given assignment.
This is based entirely on the grade (or lack of grade).
However, we also want to provide a function that returns the students to grade 
with the time of the latest submission (or rather grading time).

The first function will take the course code as first argument, the assignment 
title as the second.
The output will be a list of KTH usernames, that is without @kth.se at the end.

In case the regexes for course and assignments match several courses, we sort 
and return only unique students.
So that we don't grade the same student twice.

Finally, we exclude empty usernames from the output.
We can't do anything about them anyway.
(Students who have left the course, or KTH, have no username.)
We exclude those by using AWK to filter out empty columns (although it's just 
one column in this case.)
<<function returning students to grade>>=
students_to_grade() {
  canvaslms submissions -l -c "${1}" -a "${2}" \
    | <<strip ending [[\r]]s>> \
    | <<exclude those who passed>> \
    | cut -f 3 \
    | sort -u \
    | awk -F'\t' '$1 != ""' \
    | sed "s/@kth.se//"
}
@

We exclude those who have already passed (grade P).
We don't need to grade them again.
<<exclude those who passed>>=
awk -F'\t' '$4 != "P"'
@

For the second function, we want to find out who have been graded before and at 
what time.
This function takes the course as first argument, assignment as the second; it 
returns the student KTH identifier (third column) and a time stamp of last 
grading (sixth column).

For those who haven't been graded before, the last column will be empty.
So we rewrite that to an all-zero date.
We also normalize all timestamps to ISO 8601 format (YYYY-MM-DDTHH:MM:SS+TZ)
to match the format from git log, ensuring proper comparison.
Canvas timestamps are in local time (Stockholm timezone).
We detect the current timezone offset dynamically to handle both summer time
([[+02:00]]) and winter time ([[+01:00]]) correctly.
<<function returning students to grade with last grading time>>=
students_with_grading_time() {
  local tz=$(date +%:z)
  canvaslms submissions -l -c "$1" -a "$2" \
    | <<strip ending [[\r]]s>> \
    | <<exclude those who passed>> \
    | cut -f 3,6 \
    | sort -u \
    | awk -F'\t' -v timezone="$tz" -v OFS='\t' '$1 != "" {
        if ($2 == "" || $2 == "N/A")
          print $1, "0000-00-00T00:00:00+00:00"
        else if ($2 !~ /T/) {
          split($2, parts, " ")
          print $1, parts[1] "T" parts[2] ":00" timezone
        }
        else
          print $0
      }' \
    | sed "s/@kth.se//"
}
@

\subsection{Stripping carriage returns from canvaslms output}

The [[canvaslms]] command outputs lines ending with [[\r]] (carriage return,
Windows-style line endings).
This causes problems in shell processing:
\begin{itemize}
\item AWK field separators don't recognize [[\r]] as whitespace
\item String comparisons fail when [[\r]] is included in values
\item Piping to other commands produces unexpected results
\item Pattern matching with [[grep]], [[sed]], and [[awk]] behaves incorrectly
\end{itemize}

We must strip these carriage returns from all [[canvaslms]] output immediately
after the command, before any further processing.
This is done with [[sed 's/\r$//']].
<<strip ending [[\r]]s>>=
sed 's/\r$//'
@


\section{Clone repos}

The LaTeX reports that we should grade are found in repos on KTH GitHub.
The first argument to the function is the GitHub organization name.
The remaining arguments are the students' usernames.
The function returns the path to the cloned repos.

We'll use [[repobee]] to clone those repos to a temporary directory.
There are several ways to pass the necessary settings to [[repobee]]: username, 
GitHub API URL, access token.
We will pass them by command line.
<<clone repos>>=
clone_repos() {
  local org="$1"; shift
  local repos=$(mktemp -d)
  local students=$(mktemp)

  mkdir -p "$repos"
  echo "$repos"

  for s in "$@"; do
    echo "$s" >> "$students"
  done

  test -s "$students" || return 0

  if ! (cd "$repos" && repobee repos clone \
    -u "$REPOBEE_USER" --bu "$REPOBEE_URL" -t "$REPOBEE_TOKEN" \
      -qq --sf "$students" -o "$org" --discover-repos 2>&1); then
    echo "Warning: repobee clone failed for organization $org" >&2
    echo "Check that REPOBEE_USER, REPOBEE_URL, and REPOBEE_TOKEN are set" >&2
    echo "Student list in: $students" >&2
  fi

  rm "$students"
}
@


\section{Check dates on repos}

Now we must check the date of the last change to the repo and compare to when 
we graded it the last time.
If the repo is newer, it should be graded.

The function takes the path to the downloaded repos as first parameter.
It reads the students with times stamps from standard input.
It then outputs only those who should be graded.
<<check dates on repos>>=
students_to_actually_grade() {
  local students_w_times=$(cat)
  local repos="$1"

  for s in $(echo "$students_w_times" | cut -f 1); do
    time=$(echo "$students_w_times" | egrep "^$s\s" | cut -f 2)

    while IFS= read -r -d '' r; do
      repo_time=$(git -C "$r" log -1 --format=\%cI 2>/dev/null)
      if [[ -n "$repo_time" ]] && [[ "$time" < "$repo_time" ]]; then
        echo "$s"
      fi
    done < <(find "$repos/$s" -mindepth 1 -maxdepth 1 -type d -print0 2>/dev/null)
  done
}
@


\section{Handle SSH logins}

Now, we also want to log into remote systems using SSH.
To do this we must handle logging in with the correct user.
When running in Docker, the default would be root.
To make the rest of the code much easier\footnote{%
  The need for this arose when we started using the [[dbosk/grader]] Docker 
  image, since that one didn't include the username in the SSH config file.
  So an alternative solution would be to include an SSH config file and update 
  the one available in [[~/.ssh/config]] in the [[dbosk/grader]] image.
}, we will simply create a shell function [[ssh]] that replaces the real 
[[ssh]].
This way we can create a sort of alias for the [[ssh]] command that adds the 
appropriate user.

We need two things, (1) the path to the original [[ssh]] executable, (2) the 
username to use.

Fortunately, we can get the original path to [[ssh]] by using [[which]] 
\emph{before} we have replaced it with our own function.
(Depending on which [[which]] is used, Bash's built-in or the executable, the 
emphasis on before might not be necessary.)
<<variables>>=
SSH_PATH=$(which ssh)
@

The username we can get from the Kerberos login ([[KRB_USER]]).
We simply need to remove the [[@REALM]] from there.
<<variables>>=
SSH_USER=$(echo ${KRB_USER} | sed "s/@.*$//")
@

Now we simply let the function add [[-l ${SSH_USER}]] to the arguments of the
[[ssh]] command ([[${SSH_PATH}]]).
Then we simply pass all arguments to the function on to the real [[ssh]]
command.
We use [["$@"]] to properly preserve argument boundaries and handle arguments
with spaces.
<<handle ssh logins>>=
function ssh() {
  ${SSH_PATH} -l "${SSH_USER}" "$@"
}
