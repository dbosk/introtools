We want to grade the \emph{The terminal} assignment, that is, the students 
should place a file containing the output of their [[history]] command in 
[[~/Public/datintro/history.txt]].

We will use the [[canvaslms]] command to report the grades. This must be installed 
from
\begin{center}
  \texttt{https://github.com/dbosk/canvaslms}.
\end{center}

We will do this as a shell script.
<<grade.sh>>=
#!/bin/bash
# This file is generated from grade.sh.nw

<<configuration variables>>

source common.sh

<<function taking a list of students and returning passes>>
<<grade students>>
@

\section{Settings}

We need a few variables as settings.
We must set the course code, in the [[COURSE_CODE]] variable.
This is a space-separated list of regular expressions.
We expect the course code to be set by the environment.

We must also set the [[ASSIGNMENT]] variable. This is a regular expression.
Currently, the course names are the following:
\begin{verbatim}
DD1301 HT25/VT26 (datintro25)	LAB1	Guide to accessing the terminal			
DD1301 HT25/VT26 (datintro25)	LAB1	The terminal			
DD1301 HT25/VT26 (datintro25)	LAB1	Git			
DD1301 HT25/VT26 (datintro25)	LAB1	Writing a report in LaTeX			
DD1337 HT25 (prginda25)	LAB1	Guide to accessing the terminal			
DD1337 HT25 (prginda25)	LAB1	Working in the terminal @<<< The Lab To Do			
DD1337 HT25 (prginda25)	LAB1	Managing work with Git/GitHub @<<< The Lab To Do			
DD1337 HT25 (prginda25)	LAB1	Writing a report in LaTeX @<<< The Lab To Do			
\end{verbatim}
<<configuration variables>>=
ASSIGNMENT="^(The terminal|Working in the terminal)( @<<< [Tt]he [Ll]ab [Tt]o [Dd]o)? *$"
@


\section{Get and check the public history files}

We can't [[scp]] each student's file to us and check, that will enable some DoS 
protection.
Then we have two options:
\begin{enumerate}
\item\label{scriptonserver} We send a list of students to the server, run a 
script there to do the checks there, then receive back who passed.
\item\label{getent} We send a list of students to the server, get the paths to 
the home directory for each student and pass that back.
The we can access their home directories through AFS.
\end{enumerate}
We've tried option \ref{scriptonserver}.
The downside with this is that it doesn't allow feedback to be posted for the 
students.

We opt for option \ref{getent}.
We pass a list of student usernames to the server and return a list containing 
user:path.
We first upload a script to the server, then run it passing the list of 
students through stdin.
The function takes the list of students as the list of arguments.

We want to rotate between the shell server to not trigger any load protections.
The faculty-shell server seems to go unavailable (network unreachable) after a 
few invocations.
We favour the staff server, by two thirds.
We also introduce a small delay between runs.
<<function to get home directory>>=
get_home_directory() {
  local shellserver="$(shuf -n1 -e faculty staff staff)-shell.sys.kth.se"
  local script='
    read students;
    for s in $students; do
      dir=$(getent passwd $s | cut -d : -f 6);
      echo "$s:$dir";
    done
  '
  local scriptname=$(echo $script | ssh ${shellserver} \
    'read script; fn=$(mktemp); echo $script > $fn; echo $fn' 2> /dev/null)

  sleep 2

  echo $* | ssh ${shellserver} /bin/bash ${scriptname} \
    2> /dev/null

  sleep 2

  ssh ${shellserver} rm -Rf ${scriptname} 2> /dev/null

  sleep 30
}
@

Now we can check the history files.
We provide a function that takes a list of students, checks the history file of 
the student, grades the student (and provides feedback) accordingly.
The feedback is passed through stdout.
We only provide feedback if the student has made changes to files in the Public 
directory since the last grading date. This way we avoid giving feedback for old 
attempts.
The grade is indicated by the return value (1 for fail, 0 for pass).

First, we define a helper function to check if there are any recent changes in 
the Public directory. The function takes the path to the Public directory and the 
grading time as parameters. It returns "yes" if there are files newer than the 
grading time, "no" otherwise.
<<function to check if Public has recent changes>>=
has_recent_public_changes() {
  local public_path=$1
  local grading_time=$2
  
  # If grading_time is empty or all zeros, consider it as no previous grading
  if [ -z "$grading_time" ] || [ "$grading_time" = "0000-00-00" ]; then
    echo "yes"
    return 0
  fi
  
  # Find the newest file in Public directory
  local newest_file=$(find "$public_path" -type f -printf '%T@ %p\n' 2>/dev/null \
    | sort -n | tail -1 | cut -d' ' -f2-)
  
  if [ -z "$newest_file" ]; then
    echo "no"
    return 0
  fi
  
  # Get the modification time of the newest file in ISO 8601 format
  local newest_time=$(stat -c %y "$newest_file" 2>/dev/null | cut -d'.' -f1 | sed 's/ /T/')
  
  # Compare times (ISO 8601 format allows lexicographic comparison)
  if [[ "$newest_time" > "$grading_time" ]]; then
    echo "yes"
  else
    echo "no"
  fi
}
@

Now we can check the history files.
<<function taking a list of students and returning passes>>=
<<function to get home directory>>
<<function to check if Public has recent changes>>

grade_history_file() {
  local student=$1
  local homedir=$2
  local grading_time=$3
  local path="/afs/kth.se/$homedir/Public/datintro"
  local filepath="$path/history.txt"
  local public_path="/afs/kth.se/$homedir/Public"

  # Check if there are recent changes in Public directory
  local has_recent_changes=$(has_recent_public_changes "$public_path" "$grading_time")

  # Only provide feedback if there are recent changes
  if [ "$has_recent_changes" != "yes" ]; then
    # No recent changes, just return failure without feedback
    if ! [ -d $path ] || ! [ -f $filepath ] || ! [ -r $filepath ] || \
       ! egrep " *[0-9]+.* history *>>? *([^ ]+/)?history.txt" $filepath > /dev/null; then
      return 1
    fi
    return 0
  fi

  # Provide specific feedback based on the failure mode
  if ! [ -d $path ]; then
    echo "Can't find the 'datintro' directory in the 'Public' directory in your home directory. Please ensure you create it in the correct location (~/Public/datintro)."
    return 1
  elif ! [ -f $filepath ]; then
    echo "Can't find the file 'history.txt' in the 'Public/datintro' directory in your home directory. Please ensure you create it in the correct location (~/Public/datintro/history.txt)."
    return 1
  elif ! [ -r $filepath ]; then
    echo "The file 'Public/datintro/history.txt' exists but cannot be read. This usually means you created the file outside the 'Public' directory and then moved it there. Files must be created directly in the 'Public' directory to inherit the correct permissions. Please remove the 'datintro' directory and create it again inside 'Public', then create the 'history.txt' file there. Warning: Never remove the 'Public' directory itself."
    return 1
  elif ! egrep " *[0-9]+.* history *>>? *([^ ]+/)?history.txt" $filepath \
    > /dev/null;
  then
    echo "Found 'Public/datintro/history.txt' in your home directory, but it doesn't have the correct content. Please read the assignment instructions carefully and ensure you redirect the output of the 'history' command to the file."
    return 1
  fi
}
@


\section{Grading}

Now we provide a function [[grade_students]] which takes the assignment name as 
the first argument (it's a regex passed to [[canvaslms]]). The remaining 
arguments constitutes a list of courses.

To grade, we iterate through the remaining students, given by 
[[students_with_grading_time]] (from [[common.sh]]).
We get the home directories of the students through [[get_home_directory]].
Then we can iterate through the student--home directory tuples and grade 
them.
We pass the grading time to [[grade_history_file]] so it can check if there 
are recent changes in the Public directory before providing feedback.
Depending on the grade we report P or F.
<<grade students>>=
grade_students() {
  local assignment="$1"
  shift

  local feedback=$(mktemp)

  for course in $*; do
    local students_times=$(mktemp)
    students_with_grading_time "${course}" "${assignment}" > ${students_times}

    for student_time in $(cat ${students_times}); do
      local student=$(echo $student_time | cut -f 1)
      local grading_time=$(echo $student_time | cut -f 2)
      
      local student_home=$(get_home_directory "$student")
      local homedir=$(echo "$student_home" | cut -f 2 -d:)

      if grade_history_file "$student" "$homedir" "$grading_time" > "$feedback"; then
        echo "$student (terminal)"

        canvaslms grade -c "${course}" -a "${assignment}" \
          -u $student@kth.se -g P &

        sleep 0.2
      elif [ -s "$feedback" ]; then
        canvaslms grade -c "${course}" -a "${assignment}" \
          -u $student@kth.se -g F -m "$(cat "$feedback")" &
      fi
    done

    rm ${students_times}
  done

  wait
}

grade_students "${ASSIGNMENT}" ${COURSE_CODE}
@
