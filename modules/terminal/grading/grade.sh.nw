We want to grade the \emph{The terminal} assignment, that is, the students 
should place a file containing the output of their [[history]] command in 
[[~/Public/datintro/history.txt]].

We will use the [[canvaslms]] command to report the grades. This must be installed 
from
\begin{center}
  \texttt{https://github.com/dbosk/canvaslms}.
\end{center}

We will do this as a shell script.
<<grade.sh>>=
#!/bin/bash
# This file is generated from grade.sh.nw

<<configuration variables>>

source common.sh

<<function taking a list of students and returning passes>>
<<grade students>>
@

\section{Settings}

We need a few variables as settings.
We must set the course code, in the [[COURSE_CODE]] variable.
This is a space-separated list of regular expressions.
We expect the course code to be set by the environment.

We must also set the [[ASSIGNMENT]] variable. This is a regular expression.
Currently, the course names are the following:
\begin{verbatim}
DD1301 HT25/VT26 (datintro25)	LAB1	Guide to accessing the terminal			
DD1301 HT25/VT26 (datintro25)	LAB1	The terminal			
DD1301 HT25/VT26 (datintro25)	LAB1	Git			
DD1301 HT25/VT26 (datintro25)	LAB1	Writing a report in LaTeX			
DD1337 HT25 (prginda25)	LAB1	Guide to accessing the terminal			
DD1337 HT25 (prginda25)	LAB1	Working in the terminal @<<< The Lab To Do			
DD1337 HT25 (prginda25)	LAB1	Managing work with Git/GitHub @<<< The Lab To Do			
DD1337 HT25 (prginda25)	LAB1	Writing a report in LaTeX @<<< The Lab To Do			
\end{verbatim}
<<configuration variables>>=
ASSIGNMENT="^(The terminal|Working in the terminal)( @<<< [Tt]he [Ll]ab [Tt]o [Dd]o)? *$"
@


\section{Get and check the public history files}

We can't [[scp]] each student's file to us and check, that will enable some DoS
protection.
Then we have two options:
\begin{enumerate}
\item\label{scriptonserver} We send a list of students to the server, run a
script there to do the checks there, then receive back who passed.
\item\label{getent} We send a list of students to the server, get the paths to
the home directory for each student and pass that back.
The we can access their home directories through AFS.
\end{enumerate}
We've tried option \ref{scriptonserver}.
The downside with this is that it doesn't allow feedback to be posted for the
students.

We opt for option \ref{getent}.
We pass a list of student usernames to the server and return a list containing
user:path.
We first upload a script to the server, then run it passing the list of
students through stdin.
The function takes the list of students as the list of arguments.

We want to rotate between the shell server to not trigger any load protections.
The faculty-shell server seems to go unavailable (network unreachable) after a
few invocations.
We favour the staff server, by two thirds.
We also introduce a small delay between runs.
<<function to get home directory>>=
get_home_directory() {
  local shellserver="$(shuf -n1 -e faculty staff staff)-shell.sys.kth.se"
  local script='
    read students;
    for s in $students; do
      dir=$(getent passwd $s | cut -d : -f 6);
      echo "$s:$dir";
    done
  '
  local scriptname=$(echo $script | ssh ${shellserver} \
    'read script; fn=$(mktemp); echo $script > $fn; echo $fn' 2> /dev/null)

  sleep 2

  echo $* | ssh ${shellserver} /bin/bash ${scriptname} \
    2> /dev/null

  sleep 2

  ssh ${shellserver} rm -Rf ${scriptname} 2> /dev/null

  sleep 30
}
@

Now we can check the history files.
We provide a function that takes a list of students, checks the history file of
the student, grades the student (and provides feedback) accordingly.
The feedback is passed through stdout.
The grade is indicated by the return value (1 for fail, 0 for pass).
<<function taking a list of students and returning passes>>=
<<function to get home directory>>

grade_history_file() {
  local student=$1
  local homedir=$2
  local path="/afs/kth.se/$homedir/Public/datintro"
  local filepath="$path/history.txt"

  if ! [ -d $path ]; then
    echo "Can't find datintro directory in directory Public in your home directory."
    return 1
  elif ! [ -f $filepath ]; then
    echo "Can't find history.txt located in directory Public/datintro in your home directory."
    return 1
  elif ! egrep " *[0-9]+.* history *>>? *([^ ]+/)?history.txt" $filepath \
    > /dev/null;
  then
    echo "Found Public/datintro/history.txt in your home directory, but it seems to have the wrong format."
    return 1
  fi
}
@
\section{Grading}

Now we provide a function [[grade_students]] which takes the assignment name as 
the first argument (it's a regex passed to [[canvaslms]]). The remaining 
arguments constitutes a list of courses.

To grade, we iterate through the remaining students, given by 
[[students_to_grade]] (from [[common.sh]]).
We get the home directories of the students through [[get_home_directory]].
Then we can iterate through the student--home directory tuples and grade 
them.
Depending on the grade we report P or F.
<<grade students>>=
grade_students() {
  local assignment="$1"
  shift

  for course in $*; do
    students_to_grade "${course}" "${assignment}" | \
      generate_feedback_for_students | report_feedback "${course}" "${assignment}"
  done

  wait
}

grade_students "${ASSIGNMENT}" ${COURSE_CODE}
@


\section{Report feedback for the public history files}

We can't [[scp]] each student's file to us and check, that will enable some DoS 
protection at KTH.
So we must send a list of students to the server and do the checks there, then 
receive the feedback and who passed.

We send the script over, then we run it and pass all the students to it.
Note that the script will end up on one line, hence the semi-colons.
The script will output the feedback to files, use [[tar]] to compress the files 
and deliver them back (meaning printing the tarball to stdout).
On the receiving end, we'll use tar to change them into files again.
Then we can use the files for feedback.

The function [[generate_feedback_for_students]] takes the list of students on 
stdin.
Then it returns a directory where the feedback for each student is located in a 
file named by the student's username.
<<function taking a list of students and returning passes>>=
generate_feedback_for_students() {
  local script='
    <<script to run on remote server>>
  '
  local n=$(shuf -i 1-3 -n 1)
  local scriptname=$(echo $script | ssh student-shell-${n}.sys.kth.se \
    'script=$(cat); fn=$(mktemp); echo "$script" > $fn; echo $fn' 2> /dev/null)
  local results=$(mktemp -d)

  cd $results
  echo $* | ssh student-shell-${n}.sys.kth.se /bin/bash ${scriptname} \
    2> /dev/null | tar -zxf -

  echo $results
}

report_feedback() {
  local course="$1"
  local assignment="$2"
  local feedback_dir=$(cat)

  cd $feedback_dir

  for s in $(ls); do
    <<check the feedback for student s>>
  done

  cd .. && rm -Rf $feedback_dir
}
@

The students must be read from stdin, so the first command must to that.
Then we create a temporary directory, iterate through the students and put any 
feedback into a file named by the student's username.
If the student passes, we must create an empty feedback file.
Students who don't have a file should be ignored.
<<script to run on remote server>>=
students=$(cat)
results=$(mktemp -d)

for s in $students; do
  dir=$(getent passwd $s | cut -d : -f 6)
  if ! [[ -e ${dir}/Public/datintro/history.txt ]]; then
    continue
  fi
  if ! egrep " *[0-9]+.* history *>>? *([^ ]+/)?history.txt" \
        ${dir}/Public/datintro/history.txt > /dev/null; then
    echo "The contents of history.txt doesn't seem correct." > $results/$s
  else
    touch $results/$s
  fi
done

tar -zcf - $results/*

rm -Rf $results
@

We receive the feedback in a file named by the student identifier in the [[s]]
variable.
Now we need to check if the feedback is empty, which is a pass.
Any feedback is a fail and should be included as a comment to the student.
<<check the feedback for student s>>=
if [[ -s $s ]]; then
  echo "$s (attempted terminal)"

  canvaslms grade -c "${course}" -a "${assignment}" \
    -u ${s}@kth.se -g F -m "$(cat $s)" &
else
  echo "$s (terminal)"

  canvaslms grade -c "${course}" -a "${assignment}" \
    -u ${s}@kth.se -g P &
fi

sleep 0.1
@

