We want to grade the \emph{The terminal} assignment, that is, the students 
should place a file containing the output of their [[history]] command in 
[[~/Public/datintro/history.txt]].

We will use the [[canvas]] command to report the grades. This must be installed 
from
\begin{center}
  \texttt{https://github.com/dbosk/canvasy}.
\end{center}

We will do this as a shell script.
<<grade.sh>>=
#!/bin/bash
# This file is generated from grade.sh.nw
<<configuration variables>>
<<function returning students to grade>>
<<function taking a list of students and returning passes>>
<<grade students>>
@

\section{Settings}

We need a few variables as settings.
We must set the course code. This is a regular expression.
<<configuration variables>>=
COURSE_CODE="DD1301HT20 DD1301HT21 DD1337HT21"
@
We must set the [[ASSIGNMENT]] variable. This is a regular expression.
<<configuration variables>>=
ASSIGNMENT="(The terminal)"
@


\section{Students to grade}

We will construct a function that returns a list of students who need grading 
for a given assignment.

This function will take the course code as first argument, the assignment title 
as the second.
This list will contain their Canvas ID (first column) and their KTH username 
(second column).
<<function returning students to grade>>=
students_to_grade() {
  local students=$(mktemp)

  canvas users -sc "${1}" 2> /dev/null | cut -f 1,2 | sort -k 1 | \
    sed "s/@kth.se//" > ${students}

  canvas submissions -c "${1}" -a "${2}" | grep -v P | \
    cut -f 1 | sort | join -t $'\t' ${students} -

  rm ${students}
}
@


\section{Grading}

Now we provide a function [[grade_students]] which takes the assignment name as 
the first argument (it's a regex passed to [[canvas]]). The remaining arguments 
constitutes a list of courses.

To grade, we iterate through the remaining students, given by 
[[students_to_grade]].
We send the list of students to [[check_valid_histories]], which returns only 
those who passed.
Then we can simply report those with [[canvas]].
We run [[canvas]] in parallel to save time, but we need to add a delay to not 
run in to Canvas' DoS protection.
<<grade students>>=
grade_students() {
  local assignment="$1"
  shift

  for course in $*; do
    students_to_grade "${course}" "${assignment}" | \
      generate_feedback_for_students | report_feedback

    (cd $feedback; for s in *; do
      cat $s | report_feedback $s
    done)

    rm -Rf $feedback
  done

  wait
}

grade_students "${ASSIGNMENT}" ${COURSE_CODE}
@


\section{Report feedback for the public history files}

We can't [[scp]] each student's file to us and check, that will enable some DoS 
protection at KTH.
So we must send a list of students to the server and do the checks there, then 
receive the feedback and who passed.

We send the script over, then we run it and pass all the students to it.
Note that the script will end up on one line, hence the semi-colons.
The script will output the feedback to files, use [[tar]] to compress the files 
and deliver them back (meaning printing the tarball to stdout).
On the receiving end, we'll use tar to change them into files again.
Then we can use the files for feedback.

The function [[generate_feedback_for_students]] takes the list of students on 
stdin.
Then it returns a directory where the feedback for each student is located in a 
file named by the student's username.
<<function taking a list of students and returning passes>>=
generate_feedback_for_students() {
  local script='
    <<script to run on remote server>>
  '
  local n=$(shuf -i 1-3 -n 1)
  local scriptname=$(echo $script | ssh student-shell-${n}.sys.kth.se \
    'script=$(cat); fn=$(mktemp); echo "$script" > $fn; echo $fn' 2> /dev/null)
  local results=$(mktemp -d)

  cd $results
  echo $* | ssh student-shell-${n}.sys.kth.se /bin/bash ${scriptname} \
    2> /dev/null | tar -zxf -

  echo $results
}

report_feedback() {
  local feedback_dir=$(cat)

  cd $feedback_dir

  for s in $(ls); do
    <<check the feedback for student s>>
  done
  
  cd .. && rm -Rf $feedback_dir
}
@

The students must be read from stdin, so the first command must to that.
Then we create a temporary directory, iterate through the students and put any 
feedback into a file named by the student's username.
If the student passes, we must create an empty feedback file.
Students who don't have a file should be ignored.
<<script to run on remote server>>=
students=$(cat)
results=$(mkdtemp -d)

for s in $students; do
  dir=$(getent passwd $s | cut -d : -f 6)
  if ! [[ -e ${dir}/Public/datintro/history.txt ]]; then
    continue
  fi
  if ! egrep " *[0-9]+.* history *>>? *([^ ]+/)?history.txt" \
        ${dir}/Public/datintro/history.txt > /dev/null; then
    echo "The contents of history.txt doesn't seem correct." > $results/$s
  else
    touch $results/$s
  fi
done

tar -zcf - $results/*

rm -Rf $results
@

We receive the feedback in the [[feedback]] variable and the student identifier 
in the [[s]] variable.
Now we need to check if the feedback is empty, which is a pass.
Any feedback is a fail and should be included as a comment to the student.
<<check the feedback for student s>>=
if [[ $(wc -l $s) -gt 0 ]]; then
  echo "$s (attempted terminal)"

  canvas grade -c "${course}" -a "${assignment}" \
    -u $(grep $s ${students} | cut -f 1) -g F -m "$(cat $s)" &
else
  echo "$s (terminal)"

  canvas grade -c "${course}" -a "${assignment}" \
    -u $(grep $s ${students} | cut -f 1) -g P &
fi

sleep 0.1
@

